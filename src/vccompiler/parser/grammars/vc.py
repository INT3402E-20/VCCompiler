from vccompiler.lexer.token import TokenEnum
from vccompiler.ll1 import Format, LL1Grammar, Symbol


program = Symbol("program")   # start symbol
declare_type = Symbol("declare-type")
vc_type = Symbol("type", TokenEnum.TYPE_INIT)
identifier = Symbol("identifier", TokenEnum.IDENTIFIER)

func_decl = Symbol("func-decl")
para_list = Symbol("para-list")
compound_stmt = Symbol("compound-stmt")
proper_para_list = Symbol("proper-para-list")
temp_para_list = Symbol("temp-para-list")
para_decl = Symbol("para-decl")
array_decl = Symbol("array-decl")
array_size = Symbol("array-size")

temp_compound = Symbol("temp-compound")
var_decl = Symbol("var-decl")
temp_compound_next = Symbol("temp-compound-next")
init_decl_tial = Symbol("init-decl-tial")
temp_init_decl = Symbol("temp-init-decl")
init_decl = Symbol("init-decl")
initialiser = Symbol("initialiser")
many_expr = Symbol("many-expr")
expr = Symbol("expr")

stmt = Symbol("stmt")
if_stmt = Symbol("if-stmt")
for_stmt = Symbol("for-stmt")
while_stmt = Symbol("while-stmt")
break_stmt = Symbol("break-stmt")
continue_stmt = Symbol("continue-stmt")
return_stmt = Symbol("return-stmt")
expr_stmt = Symbol("expr-stmt")
is_expr = Symbol("is-expr")

grammar = LL1Grammar(program)
# grammar.add_rule(program, func_decl, program)

grammar.add_rule(program, vc_type, identifier, declare_type, program)
grammar.add_rule(program, Symbol.eps)
grammar.add_rule(declare_type, func_decl)
grammar.add_rule(declare_type, var_decl)

grammar.add_rule(func_decl, para_list, compound_stmt)
grammar.add_rule(para_list, "(", proper_para_list, ")")
grammar.add_rule(proper_para_list, para_decl, temp_para_list)
grammar.add_rule(proper_para_list, Symbol.eps)
grammar.add_rule(temp_para_list, ",", para_decl, temp_para_list)
grammar.add_rule(temp_para_list, Symbol.eps)
grammar.add_rule(para_decl, vc_type, identifier, array_decl)
grammar.add_rule(array_decl, "[", array_size, "]")
grammar.add_rule(array_decl, Symbol.eps)
grammar.add_rule(array_size, TokenEnum.INTLITERAL)
grammar.add_rule(array_size, Symbol.eps)

grammar.add_rule(compound_stmt, "{" , temp_compound_next, "}")
grammar.add_rule(temp_compound, vc_type, var_decl, temp_compound_next)
grammar.add_rule(temp_compound, stmt, temp_compound_next)
grammar.add_rule(temp_compound_next, temp_compound)
grammar.add_rule(temp_compound_next, Symbol.eps)

grammar.add_rule(var_decl, array_decl, init_decl_tial, temp_init_decl, ";")
grammar.add_rule(temp_init_decl, ",", init_decl, temp_init_decl)
grammar.add_rule(temp_init_decl, Symbol.eps)
grammar.add_rule(init_decl, identifier, array_decl, init_decl_tial)
grammar.add_rule(init_decl_tial, "=", initialiser)
grammar.add_rule(init_decl_tial, Symbol.eps)
grammar.add_rule(initialiser, expr)
grammar.add_rule(initialiser, "{", expr, many_expr, "}")
grammar.add_rule(many_expr, ",", expr, many_expr)
grammar.add_rule(many_expr, Symbol.eps)

grammar.add_rule(stmt, compound_stmt)
grammar.add_rule(stmt, if_stmt)
grammar.add_rule(stmt, for_stmt)
grammar.add_rule(stmt, while_stmt)
grammar.add_rule(stmt, break_stmt)
grammar.add_rule(stmt, continue_stmt)
grammar.add_rule(stmt, return_stmt)
grammar.add_rule(stmt, expr_stmt)

grammar.add_rule(if_stmt, "if", "(", expr, ")", stmt, "else", stmt)
grammar.add_rule(for_stmt, "for", "(", is_expr, ";", is_expr, ";", is_expr, ")", stmt)
grammar.add_rule(is_expr, expr)
grammar.add_rule(is_expr, Symbol.eps)
grammar.add_rule(while_stmt, "while", "(", expr, ")", stmt)
grammar.add_rule(break_stmt, "break", ";")
grammar.add_rule(continue_stmt, "continue", ";")
grammar.add_rule(return_stmt, "return", is_expr, ";")
grammar.add_rule(expr_stmt, is_expr, ";")

# Continue with expr rule